---
layout: /src/layouts/MarkdownPostLayout.astro
title: From bare window to 2D physics - Part 1 Intro
author: Krzysztof KrysiÅ„ski
authorImage: "https://avatars.githubusercontent.com/u/25402427?v=4"
description: "Did you ever wonder how 2D rendering actually works? Well this is what I'll try to cog out in this series."
image:
  url: "/images/posts/2d-rendering-part1.webp"
  alt: "Cover image of the blog post"
pubDate: 2025-05-21
tags:
  [
    "2d", "rendering"
  ]
languages: []
---

import ClickTrophy from "../../../components/post-specific/ClickTrophy.astro";

There is a time in a man's life when he needs to make a decision. Use a game engine or build your own.

I would say it's a very important decision. You see, the temptation to connect all the little pieces and make them work exactly as you wish, up to the smallest detail is undeniable.

I would say it's an important decision, but I won't. Because it's not.
You see, there is no real difference. But to see that, we need to rephrase the question.

"Should I just not finish the game or not finish the engine to the state where I can even start making a game"

See? No difference. In either case, the thing goes to "unfinished projects, but I'll come back to them one day, I promise!1!1!1" folder.

> but flabbet

WHAT? Oh I am sorry, did I forget about that portfolio website made from a pre-made template, in which you have succesfully changed the photo and the colors with ChatGPT help?
You're right, here is your trophy. 

Click to get it.

<br/>

<ClickTrophy />

<br/>

Okay, Where was I?

Ah, the illusion of choice between a game engine.


In this series, we'll be doing the harder one, making the game engine.

## Let the rabbit hole begin

Well, not exactly, not full blown generic game engine. More like engineless 2D game. 

We'll go through:

### Theoretical funsies, that will not go to prod

such as:

1. Creating a barebones window with OS sys-calls (Windows, Linux, MacOS)
2. Rendering primitive 2D shapes
3. Listening to input (mouse, keyboard), also barebones

> What do you mean "theoretical funsies, that will not go to prod?"

For the love of God. Just because this is Unhinged Cogs and we'll do these things, it doesn't mean you actually should do it in real life projects.

This is where the second part comes in.

### A breakdown of more realistic architecture for a 2D rendering framework

Now, this is a fun thing, and not an easy one.

So, in this list you'll find:

1. GLFW/SDL - Why even Valve doesn't bother dealing with OS stuff
2. Design of a flexible graphics pipeline so it works across all major OSes and a browser.
3. Skia, because you don't want to deal with this low-level shit yourself.

Then, after this **very** exciting part:

### Actually using it to make a simple 2D physics engine

While I take some responsibility for the first 2 parts, meaning that I actually know what I am saying there. The third part is 
going to be a wild ride, where most likely, I am doing stupid shit that somehow works (or not, idk yet, still wip). 

Welcome to **Unhinged Cogs** ladies and gentlemans!


### What to *not* expect from this series

Now some important foreword before we begin.

It's not a tutorial nor a guide on how to make production ready framework for a game engine. Tons of stuff  